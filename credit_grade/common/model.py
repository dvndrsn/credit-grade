import pandas as pd
import numpy as np
from datetime import datetime
from sklearn import linear_model
from sklearn.cross_validation import train_test_split
from sklearn.externals import joblib

class CreditGradeModel:
    ''' Object for loading and training model data for determining credit grade
    from historical data. Credit grade is defined as A1 (being higest) through
    D5 (being lowest).
    '''

    # Max grade num determined by 5 grades per letter, 4 letters, starting at 0
    MAX_GRADE_NUM = 5 * 4 - 1

    def __init__(self, model):
        self.model = model

    @staticmethod
    def process_data_from_file(input_file):
        ''' Processes loan data for creating a model for prediction of
        credit grade
        '''
        # load data from input file
        cd = pd.read_csv(input_file, na_values='None', \
                        parse_dates=['business_founding_date'])

        # create new features from existing columns
        cd['business_founding_years'] = (datetime.today() - \
                                        cd['business_founding_date']).astype('timedelta64[Y]')
        cd['credit_num'] = CreditGradeModel.grade_to_num(cd['credit_grade'])

        # to train our model, we need to any records with missing values or
        # fill them with some default assumed value
        cd = cd.dropna()

        # return dataframe containing only required x and y data for training model
        x_cols = ['approved_amount', 'term_months', 'dscr',
                  'vantage_score_3_weighted', 'fico_score_weighted', 'intelliscore',
                  'bdfs_score', 'annual_revenue', 'business_founding_years']
        y_cols = ['credit_num']

        # split the data intro train/test sets and return
        return cd[x_cols], cd[y_cols]

    @staticmethod
    def train_model(x_data, y_data):
        # preprocess CSV data
        x_train, x_test, y_train, y_test = train_test_split(x_data, y_data)

        # train model from selected training records
        model = linear_model.LinearRegression()
        model.fit(x_train, y_train)

        # display stats from selected test records
        mean_sq_err = np.mean((model.predict(x_test) - y_test) ** 2)
        variance = model.score(x_test, y_test)

        print("Mean Sq. Err: {}.".format(mean_sq_err))
        print("Variance: {}.".format(variance))

        # show some info regarding the trained model
        print("Intercept: {}.".format(model.intercept_))
        print("Coefficent: {}.".format(model.coef_))

        # for x, a, p in zip(x_test, CreditGradeModel.num_to_grade(y_test), \
        #                    CreditGradeModel.num_to_grade(model.predict(x_test))):
        #     print("Data: {}. Actual: {}. Prediction: {}. Diff: {}.".format(
        #         x, a, p, CreditGradeModel.grade_to_num(a) - CreditGradeModel.grade_to_num(p)))

        return model

    @staticmethod
    def load_model(filename):
        model = joblib.load(filename)
        return model

    @staticmethod
    def save_model(model, filename):
        joblib.dump(model, filename)

    @staticmethod
    @np.vectorize
    def grade_to_num(credit_grade):
        ''' Helper function to covert a credit grade (A1, D3, B5, etc.) to a
        grade number for model training
        '''

        if len(credit_grade) > 2:
            raise ValueError("Credit grade should only be two characters")

        # determine letter from credit grade
        try:
            letter_lookup = {'A':15, 'B':10, 'C':5, 'D':0}
            letter_value = letter_lookup[credit_grade[0]]
        except:
            raise ValueError("Credit grade letter should be between A and D")

        # determine credit grade number value from credit grade
        number_value = int(credit_grade[1])

        if number_value > 5 or number_value < 1:
            raise ValueError("Credit grade number should be between 1 and 5")

        # add letter and adjusted number values (lower grade number should
        # have higher value) and return
        credit_num = letter_value + 5 - number_value

        return credit_num

    @staticmethod
    @np.vectorize
    def num_to_grade(credit_num):
        ''' Helper function to convert a credit grade number generated by model
        to the credit grade (A1, D3, B5, etc.) for sending the to the user
        '''

        # Return min / max grade at bounds of model
        if credit_num > CreditGradeModel.MAX_GRADE_NUM:
            return 'A1'
        elif credit_num < 0:
            return 'D5'

        # determine credit grade letter and number
        letter_lookup = {3: 'A', 2: 'B', 1: 'C', 0: 'D'}

        grade_letter = letter_lookup[credit_num // 5]
        grade_number = str(5 - round(credit_num) % 5)

        # concat grade and number and return
        credit_grade = grade_letter + grade_number

        return credit_grade

    def predict(self, d):
        ''' Covert dictionary to proper shape numpy array, then call predict
        '''

        # convert the dictionary of items to an array, in the expected order
        x_cols = ['approved_amount', 'term_months', 'dscr',
                  'vantage_score', 'fico_score', 'intelliscore',
                  'bdfs_score', 'annual_revenue', 'business_founding_years']
        l = []
        for k in x_cols:
            l.append(float(d[k]))
        x_data = np.array(l)

        # get the grade value from trained model and map to credit grade
        value = self.model.predict(x_data.reshape(1, -1))
        grade = CreditGradeModel.num_to_grade(value)

        # only return the first element
        return grade.flatten()[0]
